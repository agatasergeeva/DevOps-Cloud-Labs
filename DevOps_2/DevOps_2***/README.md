# Лабораторная работа №2 со звездочкой


## Для начала рассмотрим *“плохой”* Docker compose file, в котором есть три “bad practices” по написанию Docker compose file:

### Описание этих “bad practices”:
1.	**Использование latest** тега для образов:**

Это плохая практика, так как использование тега `latest` делает приложение уязвимым к неожиданным изменениям. 

2.	**Хранение конфиденциальной информации в environment:**

Это небезопасно, так как любой пользователь, имеющий доступ к файлу, сможет увидеть эти данные. 


3.	**Отсутствие явного указания зависимости между сервисами:**

В нашем файле сервис api зависит от сервиса db, но это неявно указано с помощью depends_on, который гарантирует, что контейнер db будет запущен перед api. Так как он не гарантирует, что база данных будет готова к использованию.


Для проверки работы кода, мы запустили его в github:

![bad](https://github.com/agatasergeeva/DevOps-Cloud-Labs/blob/main/DevOps_2/DevOps_2***/photo/Bad1.png)

Также прикрепляем скрин pipelines для  “bad practices”:

![sc1](https://github.com/agatasergeeva/DevOps-Cloud-Labs/blob/main/DevOps_2/DevOps_2***/photo/Bad222.png)

## Теперь рассмотрим *“хороший”* Docker compose file, в котором эти плохие практики исправлены.

### Исправление *«плохого»* Docker compose file:

1.	Мы исправили `nginx:latest` на `nginx:1.21.6`. Указание конкретной версии гарантирует, что в процессе сборки используется стабильная и проверенная версия. Это помогает избежать неожиданных проблем при выходе новой версии.
2.	Так как хранение конфиденциальной информации, такой как пароли и учетные данные, в `environment` секции может привести к утечке данных, мы использовали переменные окружения из файла `.env`.
3.	Вместо использования `depends_on`, мы реализовали логику повторных попыток подключения в приложении, используя `wait-for-it`, чтобы убедиться, что сервисы готовы к работе.


Для проверки исправленного кода, мы также запустили его в github:

![good](https://github.com/agatasergeeva/DevOps-Cloud-Labs/blob/main/DevOps_2/DevOps_2***/photo/Good1111.png)

Также прикрепляем скрин pipelines для  “good practices”:

![sc2](https://github.com/agatasergeeva/DevOps-Cloud-Labs/blob/main/DevOps_2/DevOps_2***/photo/Good22222.png)



Для настройки сервисов так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети мы используем несколько сетей и назначаем каждому сервису свою собственную сеть. Это обеспечит изоляцию между сервисами, так что они не смогут взаимодействовать друг с другом.

### Изменения

В конце файла мы определили три разные сети: webnet, apinet и dbnet. Каждая из этих сетей будет использоваться для изоляции соответствующих сервисов.  

**Принцип изоляции**

Когда контейнеры подключены к разным сетям, они не могут взаимодействовать друг с другом, так как Docker создает отдельные виртуальные сети для каждого из них, что позволяет обеспечить безопасность и контроль доступа между различными компонентами приложения. В нашем случае веб-сервер `nginx` не сможет обратиться к API-сервису, и наоборот, что может быть полезно для повышения безопасности и управления трафиком.

Теперь для проверки нового Composse file запускаем его в github:

![new](https://github.com/agatasergeeva/DevOps-Cloud-Labs/blob/main/DevOps_2/DevOps_2***/photo/new111.png)

Также прикрепляем скрин piplines:

![new2](https://github.com/agatasergeeva/DevOps-Cloud-Labs/blob/main/DevOps_2/DevOps_2***/photo/new2222222.png)
