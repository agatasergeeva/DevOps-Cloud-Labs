# Лабораторная работа №2



## Для начала напишем *“плохой”* Dockerfile, в котором есть три “bad practices” по написанию докерфайлов: 
```
FROM python:latest
COPY . /app
CMD ["python", "/app/app.py"]
```
### Описание этих “bad practices”:
1. **Использование latest**:

Это *«bad practices»*, так как `version latest` может измениться со временем и привести к неожиданному поведению приложения. 

2. **Не указан рабочий каталог**: 

Из-за этой ошибки файлы будут копироваться в корневой каталог контейнера, из-за этого данные могут оказаться в неожиданных для пользователя местах, а также из-за этого структура приложения становится менее понятной

3.	 **Запуск контейнера от root пользователя**: 

В нашем файле не указан пользователь, поэтому контейнер по умолчанию запускается от root. Это может привести к тому, что третьи лица могут получить доступ к системе. 

## Теперь напишем *“хороший”* Dockerfile, в котором эти плохие практики исправлены. 
```
FROM python:3.10-slim
WORKDIR /app
COPY . /app
RUN adduser --disabled-password --gecos '' appuser
USER appuser
CMD ["python", "/app/app.py"]
```
### Исправление «плохого» Dockerfile:
1.	Мы исправили `latest` на `python:3.10-slim`. Это позволило нам сократить размер контейнера.
   
2.	Мы указали рабочий каталог с помощью `WORKDIR /app`. Теперь все следующие команды будут выполняться внутри каталога `/app`. Файлы будут находиться в одном месте, это позволить проще находить нужные данные.

3.	Для того чтобы исправить последний *“bad practice”*, мы создали неприоритетного пользователя и запустились от его имени. Это гарантирует, что если третьи лица получат доступ, то они будут пользоваться исключительно правами неприоритетного пользователя, что улучшит безопасность контейнера 

## Описание плохих практик по работе с контейнерами:
1.	Использование `docker commit` для создания образа.
   
Не стоит создавать образы из запущенных контейнеров, так как этот способ не приносит пользы. Мы советуем всегда использовать полностью воспроизводимый Dockerfile, в таком случае возможно отследить изменения в Dockerfile, если сохранить его в гите.

2.	Полагаться на IP-адрес.
   
Каждый контейнер имеет свой собственный внутренний IP-адрес, и он, конечно же, может измениться. Если приложению требуется связь с другим контейнером, то стоит использовать переменные среды для передачи соответствующего имени хоста и порта из одного контейнера в другой.


*Вдохновились:*
1. [Первый источник](https://wiki.merionet.ru/articles/10-veshhej-kotoryx-sleduet-izbegat-v-docker-kontejnerax)

2. [Второй источник](https://bool.dev/blog/detail/top8-docker-best-practices)

